'use client';

import { useState, useEffect, useCallback } from 'react';
import { ProfessionalMenuPDFGenerator, RestaurantInfo, MenuTheme, MENU_THEMES, selectThemeForRestaurant } from '../../lib/pdf/menuGenerator';
import { ClassifiedItem, organizeMenuItems, getCategoryDisplayName, getCategoryOrder, classifyMenuItem } from '../../lib/ai/menuClassifier';
import { detectLanguage, getLanguageName, generateDescriptionInLanguage } from '../../lib/ai/languageDetector';
import { authenticatedApiCall } from '../../../lib/api-helpers';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { typography, spacing } from '@/lib/design-system';
import CategoryReviewModal from './CategoryReviewModal';

interface PDFMenuGeneratorProps {
  showSuccess: (message: string) => void;
  showError: (message: string) => void;
}

interface MenuItem {
  id: string;
  name: string;
  description?: string;
  price: number;
  category_id?: string;
  nutrition?: Record<string, unknown>;
  image_url?: string;
  categories?: {
    name: string;
  };
}

interface Restaurant {
  id: string;
  name: string;
  address?: string;
  phone?: string;
  website?: string;
  logo_url?: string;
  primary_color?: string;
  secondary_color?: string;
}

export default function PDFMenuGenerator({ showSuccess, showError }: PDFMenuGeneratorProps) {
  const [restaurant, setRestaurant] = useState<Restaurant | null>(null);
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [organizedItems, setOrganizedItems] = useState<Record<string, ClassifiedItem[]>>({});
  const [isLoading, setIsLoading] = useState(true);
  const [isGenerating, setIsGenerating] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string>('');
  
  // PDF options
  const [includeDescriptions, setIncludeDescriptions] = useState(true);
  const [includeNutrition, setIncludeNutrition] = useState(false);
  const [includeImages, setIncludeImages] = useState(false);
  const [customOrder, setCustomOrder] = useState<string[]>([]);
  
  // Theme selection
  const [selectedTheme, setSelectedTheme] = useState<MenuTheme | null>(null);
  const [aiSuggestedThemes, setAiSuggestedThemes] = useState<MenuTheme[]>([]);
  
  // Category reordering
  const [categoryOrder, setCategoryOrder] = useState<string[]>([]);

  // Language detection
  const [detectedLanguage, setDetectedLanguage] = useState<string>('english');
  const [languageConfidence, setLanguageConfidence] = useState<number>(0);
  const [autoGenerateDescriptions, setAutoGenerateDescriptions] = useState(false);

  // Category review modal
  const [showCategoryReview, setShowCategoryReview] = useState(false);
  const [classifiedItems, setClassifiedItems] = useState<ClassifiedItem[]>([]);

  const loadData = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Load restaurant info
      const restaurantResponse = await authenticatedApiCall('/api/admin/me/restaurant');
      let restaurantData: { restaurant: Restaurant } | null = null;
      if (restaurantResponse.ok) {
        restaurantData = await restaurantResponse.json();
        setRestaurant(restaurantData!.restaurant);
        
        // Generate AI-suggested themes
        const restaurantInfo: RestaurantInfo = {
          name: restaurantData!.restaurant.name,
          address: restaurantData!.restaurant.address,
          phone: restaurantData!.restaurant.phone,
          website: restaurantData!.restaurant.website,
          logo_url: restaurantData!.restaurant.logo_url,
          primary_color: restaurantData!.restaurant.primary_color,
          secondary_color: restaurantData!.restaurant.secondary_color
        };
        
        const suggestedTheme = selectThemeForRestaurant(restaurantInfo);
        setSelectedTheme(suggestedTheme);
        
        // Generate 3-4 theme suggestions
        const suggestions = generateThemeSuggestions(restaurantInfo);
        setAiSuggestedThemes(suggestions);
      }
      
      // Load menu items
      const itemsResponse = await authenticatedApiCall('/api/admin/products');
      if (itemsResponse.ok) {
        const itemsData = await itemsResponse.json();
        setMenuItems(itemsData.products || []);
        
        // Create a mapping of category IDs to category names
        const categoryMap: Record<string, string> = {};
        itemsData.products?.forEach((item: MenuItem) => {
          if (item.category_id && item.categories?.name) {
            categoryMap[item.category_id] = item.categories.name;
          }
        });
        
        // Classify all items for category review
        const classified = itemsData.products?.map((item: MenuItem) => {
          const databaseCategory = categoryMap[item.category_id || ''] || '';
          return classifyMenuItem(item, databaseCategory);
        }) || [];
        
        setClassifiedItems(classified);
        
        // Organize items by AI classification using database categories
        const organized = organizeMenuItems(itemsData.products || [], categoryMap);
        setOrganizedItems(organized);
        setCategoryOrder(getCategoryOrder());
        
        // Detect language if we have restaurant data
        if (restaurantData) {
          detectRestaurantLanguage(restaurantData.restaurant, itemsData.products || []);
        }
      }
    } catch (error) {
      console.error('Error loading data:', error);
      showError('Failed to load menu data');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    loadData();
  }, [loadData]);



  const detectRestaurantLanguage = (restaurant: Restaurant, items: MenuItem[]) => {
    const context = {
      restaurantName: restaurant.name,
      restaurantAddress: restaurant.address,
      menuItems: items.map(item => ({
        name: item.name,
        description: item.description,
        category: item.category_id
      })),
      categories: Object.keys(organizedItems)
    };

    const result = detectLanguage(context);
    setDetectedLanguage(result.detectedLanguage);
    setLanguageConfidence(result.confidence);
  };

  const generateThemeSuggestions = (restaurant: RestaurantInfo): MenuTheme[] => {
    const suggestions = [];
    
    // Always include the AI-selected theme
    const aiTheme = selectThemeForRestaurant(restaurant);
    suggestions.push(aiTheme);
    
    // Add 2-3 additional themes based on restaurant characteristics
    const name = restaurant.name.toLowerCase();
    const isFineDining = name.includes('restaurant') || name.includes('bistro');
    const isCasual = name.includes('cafe') || name.includes('bar');
    const isItalian = name.includes('italian') || name.includes('pizza');
    const isAsian = name.includes('asian') || name.includes('chinese');
    
    if (isFineDining && aiTheme.id !== 'luxury') {
      suggestions.push(MENU_THEMES.find(t => t.id === 'luxury')!);
    }
    if (isItalian && aiTheme.id !== 'rustic') {
      suggestions.push(MENU_THEMES.find(t => t.id === 'rustic')!);
    }
    if (isAsian && aiTheme.id !== 'minimal') {
      suggestions.push(MENU_THEMES.find(t => t.id === 'minimal')!);
    }
    if (isCasual && aiTheme.id !== 'modern') {
      suggestions.push(MENU_THEMES.find(t => t.id === 'modern')!);
    }
    
    // Fill remaining slots with other themes
    const usedIds = suggestions.map(t => t.id);
    const remainingThemes = MENU_THEMES.filter(t => !usedIds.includes(t.id));
    
    while (suggestions.length < 4 && remainingThemes.length > 0) {
      suggestions.push(remainingThemes.shift()!);
    }
    
    return suggestions;
  };

  const handleGeneratePDF = async () => {
    if (!restaurant || menuItems.length === 0 || !selectedTheme) {
      showError('No restaurant, menu items, or theme available');
      return;
    }

    // Show category review modal first
    setShowCategoryReview(true);
  };

  const handleCategoryReviewConfirm = async (validatedItems: ClassifiedItem[]) => {
    setShowCategoryReview(false);
    
    try {
      setIsGenerating(true);
      
      // Reorganize items with validated categories
      const validatedOrganized = organizeValidatedItems(validatedItems);
      setOrganizedItems(validatedOrganized);
      
      // Generate PDF with validated categories
      await generatePDFWithValidatedItems(validatedItems);
      
      showSuccess('Professional PDF menu generated successfully with validated categories');
    } catch (error) {
      console.error('Error generating PDF:', error);
      showError('Failed to generate PDF menu');
    } finally {
      setIsGenerating(false);
    }
  };

  const organizeValidatedItems = (items: ClassifiedItem[]): Record<string, ClassifiedItem[]> => {
    const organized: Record<string, ClassifiedItem[]> = {};
    
    items.forEach(item => {
      const category = item.aiCategory || 'uncategorized';
      if (!organized[category]) {
        organized[category] = [];
      }
      organized[category].push(item);
    });
    
    return organized;
  };

  const generatePDFWithValidatedItems = async (validatedItems: ClassifiedItem[]) => {
    if (!restaurant || !selectedTheme) {
      throw new Error('Missing restaurant or theme data');
    }

    const generator = new ProfessionalMenuPDFGenerator(selectedTheme);
    const restaurantInfo: RestaurantInfo = {
      name: restaurant.name,
      address: restaurant.address,
      phone: restaurant.phone,
      website: restaurant.website,
      logo_url: restaurant.logo_url,
      primary_color: restaurant.primary_color,
      secondary_color: restaurant.secondary_color
    };
    
    const options = {
      restaurant: restaurantInfo,
      items: validatedItems,
      theme: selectedTheme,
      includeDescriptions,
      includeNutrition,
      includeImages,
      customOrder: customOrder.length > 0 ? customOrder : undefined,
      detectedLanguage,
      autoGenerateDescriptions
    };
    
    generator.generateMenu(options);
    const filename = `${restaurant.name.replace(/[^a-zA-Z0-9]/g, '_')}_menu_${new Date().toISOString().split('T')[0]}.pdf`;
    generator.download(filename);
  };

  const generatePreview = async () => {
    if (!restaurant || menuItems.length === 0 || !selectedTheme) {
      showError('No restaurant, menu items, or theme available');
      return;
    }

    try {
      setIsGenerating(true);
      
      const generator = new ProfessionalMenuPDFGenerator(selectedTheme);
      const restaurantInfo: RestaurantInfo = {
        name: restaurant.name,
        address: restaurant.address,
        phone: restaurant.phone,
        website: restaurant.website,
        logo_url: restaurant.logo_url,
        primary_color: restaurant.primary_color,
        secondary_color: restaurant.secondary_color
      };
      
      const options = {
        restaurant: restaurantInfo,
        items: classifiedItems,
        theme: selectedTheme,
        includeDescriptions,
        includeNutrition,
        includeImages,
        customOrder: customOrder.length > 0 ? customOrder : undefined,
        detectedLanguage,
        autoGenerateDescriptions
      };
      
      generator.generateMenu(options);
      const dataUrl = generator.getDataURL();
      setPreviewUrl(dataUrl);
      
      showSuccess('Preview generated successfully');
    } catch (error) {
      console.error('Error generating preview:', error);
      showError('Failed to generate preview');
    } finally {
      setIsGenerating(false);
    }
  };



  const moveCategory = (fromIndex: number, toIndex: number) => {
    const newOrder = [...categoryOrder];
    const [movedCategory] = newOrder.splice(fromIndex, 1);
    newOrder.splice(toIndex, 0, movedCategory);
    setCategoryOrder(newOrder);
    setCustomOrder(newOrder);
  };

  const generateBulkDescriptions = async () => {
    if (!menuItems.length) {
      showError('No menu items available');
      return;
    }

    try {
      setIsGenerating(true);
      
      const itemsWithoutDescriptions = menuItems.filter(item => !item.description || item.description.trim() === '');
      
      if (itemsWithoutDescriptions.length === 0) {
        showSuccess('All items already have descriptions');
        return;
      }

      // Generate descriptions for items without them
      const updatedItems = menuItems.map(item => {
        if (!item.description || item.description.trim() === '') {
          const generatedDescription = generateDescriptionInLanguage(
            item.name,
            detectedLanguage,
            item.category_id
          );
          return { ...item, description: generatedDescription };
        }
        return item;
      });

      setMenuItems(updatedItems);
      showSuccess(`Generated descriptions for ${itemsWithoutDescriptions.length} items`);
    } catch (error) {
      console.error('Error generating bulk descriptions:', error);
      showError('Failed to generate descriptions');
    } finally {
      setIsGenerating(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className={typography.body}>Loading menu data...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Category Review Section */}
      <Card className={spacing.md}>
        <h3 className={`${typography.h3} mb-4`}>🔍 AI Category Review</h3>
        <p className={`${typography.bodySmall} mb-4`}>
          Review and adjust AI-suggested categories before generating your PDF menu. This ensures your menu follows proper menu engineering principles.
        </p>
        
        <div className="flex items-center justify-between p-4 bg-blue-50 rounded-lg">
          <div>
            <p className="text-sm font-medium">Items to review: {classifiedItems.length}</p>
            <p className="text-xs text-gray-600 mt-1">
              Language: {getLanguageName(detectedLanguage)} • Confidence: {(languageConfidence * 100).toFixed(1)}%
            </p>
          </div>
          <Button
            onClick={() => setShowCategoryReview(true)}
            disabled={isGenerating || classifiedItems.length === 0}
            className="flex items-center"
          >
            {isGenerating ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                Processing...
              </>
            ) : (
              'Review Categories'
            )}
          </Button>
        </div>
      </Card>

      {/* Theme Selection */}
      <Card className={spacing.md}>
        <h3 className={`${typography.h3} mb-4`}>🎨 Menu Theme</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          {aiSuggestedThemes.map((theme) => (
            <div
              key={theme.id}
              className={`p-4 border-2 rounded-lg cursor-pointer transition-colors ${
                selectedTheme?.id === theme.id
                  ? 'border-primary bg-primary/5'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
              onClick={() => setSelectedTheme(theme)}
            >
              <div className="flex items-center gap-2 mb-2">
                <div
                  className="w-4 h-4 rounded-full"
                  style={{ backgroundColor: theme.primaryColor }}
                />
                <span className={`${typography.body} font-medium`}>{theme.name}</span>
              </div>
              <p className={`${typography.bodySmall} text-muted-foreground`}>
                {theme.id === 'minimal' && 'Clean, modern design'}
                {theme.id === 'rustic' && 'Warm, traditional feel'}
                {theme.id === 'luxury' && 'Elegant, sophisticated'}
                {theme.id === 'modern' && 'Contemporary, sleek'}
              </p>
            </div>
          ))}
        </div>
      </Card>

      {/* PDF Options */}
      <Card className={spacing.md}>
        <h3 className={`${typography.h3} mb-4`}>⚙️ PDF Options</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <Label htmlFor="include-descriptions" className={typography.body}>
                Include Descriptions
              </Label>
              <Switch
                id="include-descriptions"
                checked={includeDescriptions}
                onCheckedChange={setIncludeDescriptions}
              />
            </div>
            <div className="flex items-center justify-between">
              <Label htmlFor="include-nutrition" className={typography.body}>
                Include Nutrition Info
              </Label>
              <Switch
                id="include-nutrition"
                checked={includeNutrition}
                onCheckedChange={setIncludeNutrition}
              />
            </div>
            <div className="flex items-center justify-between">
              <Label htmlFor="include-images" className={typography.body}>
                Include Images
              </Label>
              <Switch
                id="include-images"
                checked={includeImages}
                onCheckedChange={setIncludeImages}
              />
            </div>
          </div>
          
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <Label htmlFor="auto-descriptions" className={typography.body}>
                Auto-generate Missing Descriptions
              </Label>
              <Switch
                id="auto-descriptions"
                checked={autoGenerateDescriptions}
                onCheckedChange={setAutoGenerateDescriptions}
              />
            </div>
            
            <div>
              <Label className={typography.body}>Custom Category Order</Label>
              <Select
                value={customOrder.length > 0 ? 'custom' : 'default'}
                onValueChange={(value) => {
                  if (value === 'default') {
                    setCustomOrder([]);
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="default">Default Order</SelectItem>
                  <SelectItem value="custom">Custom Order</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      </Card>

      {/* Bulk Description Generation */}
      <Card className={spacing.md}>
        <h3 className={`${typography.h4} mb-4`}>📝 AI Description Generator</h3>
        <p className={`${typography.bodySmall} mb-4`}>
          Generate descriptions for all menu items without descriptions using AI in the detected language
        </p>
        
        <div className="flex items-center justify-between p-4 bg-blue-50 rounded-lg">
          <div>
            <p className="text-sm font-medium">Items without descriptions: {menuItems.filter(item => !item.description || item.description.trim() === '').length}</p>
            <p className="text-xs text-gray-600 mt-1">
              Language: {getLanguageName(detectedLanguage)} • Confidence: {(languageConfidence * 100).toFixed(1)}%
            </p>
          </div>
          <Button
            onClick={generateBulkDescriptions}
            disabled={isGenerating || menuItems.filter(item => !item.description || item.description.trim() === '').length === 0}
            className="flex items-center"
          >
            {isGenerating ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                Generating...
              </>
            ) : (
              'Generate Descriptions'
            )}
          </Button>
        </div>
      </Card>

      {/* Category Reordering */}
      <Card className={spacing.md}>
        <h3 className={`${typography.h4} mb-4`}>
          📋 Category Order
        </h3>
        <div className="space-y-2">
          {categoryOrder.map((category, index) => (
            <div key={category} className="flex items-center justify-between p-3 border rounded-lg">
              <span className={typography.body}>
                {index + 1}. {getCategoryDisplayName(category)}
              </span>
              <div className="flex gap-2">
                {index > 0 && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => moveCategory(index, index - 1)}
                  >
                    ↑
                  </Button>
                )}
                {index < categoryOrder.length - 1 && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => moveCategory(index, index + 1)}
                  >
                    ↓
                  </Button>
                )}
              </div>
            </div>
          ))}
        </div>
      </Card>

      {/* Action Buttons */}
      <Card className={spacing.md}>
        <div className="flex flex-col sm:flex-row gap-4">
          <Button
            onClick={generatePreview}
            disabled={isGenerating || !selectedTheme}
            variant="outline"
            className="flex-1"
          >
            {isGenerating ? 'Generating...' : 'Generate Preview'}
          </Button>
          
          <Button
            onClick={handleGeneratePDF}
            disabled={isGenerating || !selectedTheme || classifiedItems.length === 0}
            className="flex-1"
          >
            {isGenerating ? 'Generating...' : 'Generate PDF Menu'}
          </Button>
        </div>
        
        {previewUrl && (
          <div className="mt-4">
            <h4 className={`${typography.h4} mb-2`}>Preview</h4>
            <iframe
              src={previewUrl}
              className="w-full h-96 border rounded-lg"
              title="PDF Preview"
            />
          </div>
        )}
      </Card>

      {/* Category Review Modal */}
      <CategoryReviewModal
        isOpen={showCategoryReview}
        onClose={() => setShowCategoryReview(false)}
        onConfirm={handleCategoryReviewConfirm}
        items={classifiedItems}
        isLoading={false}
      />
    </div>
  );
}
