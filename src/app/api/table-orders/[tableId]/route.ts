import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase-server';

/**
 * Get active order for a table
 * GET /api/table-orders/[tableId]
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ tableId: string }> }
) {
  try {
    const { tableId } = await params;
    
    // Check if session_id is provided in request (from URL parameter)
    // This is the secure path - session_id comes from redirect endpoint
    const searchParams = request.nextUrl.searchParams;
    const sessionIdFromRequest = searchParams.get('session');

    // Check table status and session
    const { data: table, error: tableError } = await supabaseAdmin
      .from('tables')
      .select('id, status, session_id')
      .eq('id', tableId)
      .single();

    if (tableError || !table) {
      return NextResponse.json({ error: 'Table not found' }, { status: 404 });
    }

    // Block access if table is cleaning or out of service
    if (table.status === 'out_of_service' || table.status === 'cleaning') {
      return NextResponse.json({ 
        order: null, 
        tableClosed: true,
        message: 'This table is currently unavailable.'
      });
    }

    // Get session_id from table - DO NOT generate new one here
    // session_id should only be generated by the redirect endpoint (/table-redirect)
    // This GET endpoint only returns the existing session_id
    let sessionId = table.session_id;
    
    // If table doesn't have a session_id, this means:
    // 1. Old QR code was used (before redirect implementation) - allow backward compatibility
    // 2. Table was created before session_id was added - generate one as fallback
    if (!sessionId) {
      console.warn('‚ö†Ô∏è [GET ORDER] Table missing session_id - this should not happen with new QR codes');
      // For backward compatibility with old QR codes, generate one
      // But this is not the secure path - new QR codes should use redirect endpoint
      sessionId = crypto.randomUUID();
      const { error: updateError } = await supabaseAdmin
        .from('tables')
        .update({
          session_id: sessionId,
          updated_at: new Date().toISOString(),
        })
        .eq('id', tableId);

      if (updateError) {
        console.error('Error updating table session:', updateError);
      } else {
        console.log('‚ö†Ô∏è [GET ORDER] Generated session_id for backward compatibility:', sessionId);
      }
    } else {
      console.log('‚úÖ [GET ORDER] Using existing session_id:', {
        sessionId,
        tableStatus: table.status,
      });
    }
    
    // DO NOT generate new session_id when table is available
    // session_id should come from redirect endpoint or be passed in request
    // This prevents remote access by refreshing the page

    const { data: order, error } = await supabaseAdmin
      .from('table_orders')
      .select('*')
      .eq('table_id', tableId)
      .in('order_status', ['pending', 'processed'])
      .maybeSingle();

    if (error) {
      console.error('Error fetching table order:', error);
      return NextResponse.json({ error: 'Failed to fetch order' }, { status: 500 });
    }

    // Use session_id from request if provided (from redirect endpoint), otherwise use table's session_id
    const finalSessionId = sessionIdFromRequest || sessionId;
    
    console.log('üì§ [GET ORDER] Returning response with sessionId:', {
      sessionId: finalSessionId,
      source: sessionIdFromRequest ? 'request (redirect)' : 'table',
      tableStatus: table.status,
      hasOrder: !!order,
    });

    return NextResponse.json({ 
      order: order || null, 
      tableClosed: false,
      sessionId: finalSessionId || null // Return session_id to client - CRITICAL for client to store
    });
  } catch (error) {
    console.error('Error in table order GET:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * Create or update table order
 * POST /api/table-orders/[tableId]
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ tableId: string }> }
) {
  try {
    const { tableId } = await params;
    const body = await request.json();
    const { restaurantId, areaId, items, customerToken, sessionId } = body;

    // Verify session_id
    const { data: table, error: tableError } = await supabaseAdmin
      .from('tables')
      .select('id, status, session_id, updated_at')
      .eq('id', tableId)
      .single();

    if (tableError || !table) {
      return NextResponse.json({ error: 'Table not found' }, { status: 404 });
    }

    if (!restaurantId || !items || !Array.isArray(items)) {
      return NextResponse.json(
        { error: 'Missing required fields: restaurantId, items' },
        { status: 400 }
      );
    }

    // Block modifications if table is cleaning/out of service
    if (table.status === 'out_of_service' || table.status === 'cleaning') {
      return NextResponse.json(
        { error: 'This table is currently unavailable. Please contact staff if you need assistance.' },
        { status: 403 }
      );
    }

    // Ensure table always has a session_id (security requirement)
    // If table doesn't have one, generate it immediately
    if (!table.session_id) {
      console.warn('‚ö†Ô∏è [UPDATE CART] Table missing session_id, generating one');
      const newSessionId = crypto.randomUUID();
      const { error: updateError } = await supabaseAdmin
        .from('tables')
        .update({
          session_id: newSessionId,
          updated_at: new Date().toISOString(),
        })
        .eq('id', tableId);

      if (updateError) {
        console.error('Error updating table session:', updateError);
      } else {
        // Update table object for use below
        table.session_id = newSessionId;
      }
    }

    // SECURITY: Always require session_id to match - no exceptions
    // If table has a session_id, client must provide matching sessionId
    if (table.session_id && (!sessionId || table.session_id !== sessionId)) {
      console.log('‚ùå [UPDATE CART] Session ID mismatch:', {
        clientSessionId: sessionId,
        tableSessionId: table.session_id,
        tableStatus: table.status,
      });
      // Get restaurant name for error message
      const { data: restaurant } = await supabaseAdmin
        .from('restaurants')
        .select('name')
        .eq('id', restaurantId)
        .single();

      return NextResponse.json(
        { 
          error: 'Invalid session. Please scan the QR code again.',
          message: 'In order to start a new order, you need to scan the QR code on the table.',
          restaurantName: restaurant?.name || 'The restaurant'
        },
        { status: 403, headers: { 'x-session-id': table.session_id || '' } }
      );
    }

    // Check if user needs approval to add items
    if (customerToken) {
      const { data: participant } = await supabaseAdmin
        .from('table_participants')
        .select('id')
        .eq('table_id', tableId)
        .eq('customer_token', customerToken)
        .single();

      if (!participant) {
        // User is not a participant - check if they have a pending approval request
        const { data: pendingRequest } = await supabaseAdmin
          .from('table_approval_requests')
          .select('id, expires_at')
          .eq('table_id', tableId)
          .eq('requester_token', customerToken)
          .eq('status', 'pending')
          .gt('expires_at', new Date().toISOString())
          .single();

        if (!pendingRequest) {
          // No pending request - need to request approval
          return NextResponse.json(
            {
              error: 'Approval required',
              requiresApproval: true,
              message: 'Please request approval from a table participant to add items.',
            },
            { status: 403 }
          );
        } else {
          // Has pending request but not yet approved
          const timeLeft = Math.max(0, Math.floor((new Date(pendingRequest.expires_at).getTime() - Date.now()) / 1000));
          return NextResponse.json(
            {
              error: 'Approval pending',
              requiresApproval: true,
              approvalPending: true,
              requestId: pendingRequest.id,
              timeLeft,
              message: 'Waiting for approval from a table participant...',
            },
            { status: 403 }
          );
        }
      }
    }
    
    // If table doesn't have a session_id yet (should not happen, but handle it)
    if (!table.session_id) {
      console.warn('‚ö†Ô∏è [UPDATE CART] Table missing session_id, generating one and requiring QR scan');
      const newSessionId = crypto.randomUUID();
      await supabaseAdmin
        .from('tables')
        .update({
          session_id: newSessionId,
          updated_at: new Date().toISOString(),
        })
        .eq('id', tableId);
      
      const { data: restaurant } = await supabaseAdmin
        .from('restaurants')
        .select('name')
        .eq('id', restaurantId)
        .single();

      return NextResponse.json(
        { 
          error: 'Invalid session. Please scan the QR code again.',
          message: 'In order to start a new order, you need to scan the QR code on the table.',
          restaurantName: restaurant?.name || 'The restaurant'
        },
        { status: 403, headers: { 'x-session-id': newSessionId } }
      );
    }

    // Note: We don't check for closed orders here because:
    // - Closed orders are historical records and shouldn't block new orders
    // - After a table is closed (order_status='closed'), the table status is set to 'available'
    // - Customers scanning a new QR code should be able to create a new order
    // - The query below only looks for active orders (pending/processed), so closed orders are ignored

    // Get existing order or create new one
    console.log('üîµ [UPDATE CART] Looking for existing order for tableId:', tableId);
    const { data: existingOrder, error: existingOrderError } = await supabaseAdmin
      .from('table_orders')
      .select('*')
      .eq('table_id', tableId)
      .in('order_status', ['pending', 'processed'])
      .maybeSingle();

    console.log('üì¶ [UPDATE CART] Existing order check:', {
      found: !!existingOrder,
      orderId: existingOrder?.id,
      orderStatus: existingOrder?.order_status,
      itemCount: existingOrder?.order_items?.length || 0,
      customerTokens: existingOrder?.customer_tokens,
      error: existingOrderError?.message,
    });

    console.log('üìù [UPDATE CART] Items to add:', {
      itemCount: items.length,
      items: items.map((item: { product_id: string; quantity: number; name: string }) => ({
        product_id: item.product_id,
        quantity: item.quantity,
        name: item.name,
      })),
      customerToken,
    });

    // Get existing order items and make a deep copy to avoid mutation issues
    let orderItems: Array<{
      product_id: string;
      quantity: number;
      price: number;
      name: string;
      customer_id?: string;
      customer_token?: string;
      processed?: boolean;
    }> = existingOrder?.order_items ? JSON.parse(JSON.stringify(existingOrder.order_items)) : [];

    // Add or update items from this customer
    items.forEach((item: {
      product_id: string;
      quantity: number;
      price: number;
      name: string;
    }) => {
      const existingItemIndex = orderItems.findIndex(
        (oi) => oi.product_id === item.product_id && oi.customer_token === customerToken
      );

      if (existingItemIndex >= 0) {
        // Update existing item - CRITICAL: preserve processed status exactly as it was
        const existingItem = orderItems[existingItemIndex];
        const wasProcessed = existingItem.processed === true; // Explicitly check for true
        
        orderItems[existingItemIndex] = {
          ...existingItem,
          quantity: item.quantity,
          processed: wasProcessed, // Preserve processed status - only true if it was explicitly true
        };
      } else {
        // Add new item - new items are NEVER processed automatically, regardless of order status
        orderItems.push({
          ...item,
          customer_token: customerToken,
          processed: false, // Always false for new items
        });
      }
    });

    // Remove items with quantity 0
    orderItems = orderItems.filter((item) => item.quantity > 0);

    console.log('üì¶ [UPDATE CART] After processing items:', {
      finalItemCount: orderItems.length,
      finalItems: orderItems.map((item) => ({
        product_id: item.product_id,
        quantity: item.quantity,
        name: item.name,
        customer_token: item.customer_token?.substring(0, 20) + '...',
        processed: item.processed,
      })),
    });

    // Calculate totals
    const subtotal = orderItems.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const total = subtotal; // Add tax/service charge if needed

    // Get unique customer tokens
    const customerTokens = Array.from(
      new Set(orderItems.map((item) => item.customer_token).filter(Boolean))
    ) as string[];

    console.log('üí∞ [UPDATE CART] Calculated totals:', {
      subtotal,
      total,
      customerTokens: customerTokens.map((token) => token.substring(0, 20) + '...'),
    });

    if (existingOrder) {
      // Update existing order
      console.log('üîÑ [UPDATE CART] Updating existing order:', existingOrder.id);
      const { data: updatedOrder, error: updateError } = await supabaseAdmin
        .from('table_orders')
        .update({
          order_items: orderItems,
          subtotal,
          total,
          customer_tokens: customerTokens,
          updated_at: new Date().toISOString(),
        })
        .eq('id', existingOrder.id)
        .select()
        .single();

      if (updateError) {
        console.error('‚ùå [UPDATE CART] Error updating table order:', updateError);
        return NextResponse.json({ error: 'Failed to update order' }, { status: 500 });
      }

      console.log('‚úÖ [UPDATE CART] Order updated successfully:', {
        orderId: updatedOrder.id,
        itemCount: updatedOrder.order_items.length,
        status: updatedOrder.order_status,
      });

      // Mark table as occupied if it's currently available (first successful POST)
      if (table.status === 'available') {
        await supabaseAdmin
          .from('tables')
          .update({
            status: 'occupied',
            updated_at: new Date().toISOString(),
          })
          .eq('id', tableId);
        console.log('‚úÖ [UPDATE CART] Table marked as occupied');
      }

      return NextResponse.json({ 
        order: updatedOrder,
        sessionId: table.session_id // Return session_id so client can store it
      });
    } else {
      // Create new order - but first check if there's a closed order that might conflict
      console.log('üÜï [UPDATE CART] Creating new order...', {
        restaurantId,
        tableId,
        areaId,
        itemCount: orderItems.length,
        customerTokens,
      });

      // Check for any existing order (including closed) to handle the unique constraint
      const { data: anyOrder } = await supabaseAdmin
        .from('table_orders')
        .select('id, order_status')
        .eq('table_id', tableId)
        .maybeSingle();

      if (anyOrder && anyOrder.order_status === 'closed') {
        // There's a closed order - we need to create a new one, but the unique constraint prevents it
        // Solution: Update the closed order to become a new pending order
        console.log('üîÑ [UPDATE CART] Found closed order, converting to new pending order:', anyOrder.id);
        
        const { data: updatedOrder, error: updateError } = await supabaseAdmin
          .from('table_orders')
          .update({
            order_items: orderItems,
            subtotal,
            total,
            customer_tokens: customerTokens,
            order_status: 'pending',
            placed_at: null, // Reset placed_at for new order
            processed_at: null,
            closed_at: null,
            updated_at: new Date().toISOString(),
          })
          .eq('id', anyOrder.id)
          .select()
          .single();

        if (updateError) {
          console.error('‚ùå [UPDATE CART] Error converting closed order:', updateError);
          return NextResponse.json({ error: 'Failed to create order' }, { status: 500 });
        }

        console.log('‚úÖ [UPDATE CART] Closed order converted to new pending order:', {
          orderId: updatedOrder.id,
          status: updatedOrder.order_status,
          itemCount: updatedOrder.order_items.length,
        });

        // Mark table as occupied if it's currently available (first successful POST)
        if (table.status === 'available') {
          await supabaseAdmin
            .from('tables')
            .update({
              status: 'occupied',
              updated_at: new Date().toISOString(),
            })
            .eq('id', tableId);
          console.log('‚úÖ [UPDATE CART] Table marked as occupied after converting closed order');
        }

        return NextResponse.json({ 
          order: updatedOrder,
          sessionId: table.session_id // Return session_id so client can store it
        });
      }

      // No existing order (or race condition) - try to create new one
      const { data: newOrder, error: createError } = await supabaseAdmin
        .from('table_orders')
        .insert({
          restaurant_id: restaurantId,
          table_id: tableId,
          area_id: areaId || null,
          order_items: orderItems,
          subtotal,
          total,
          customer_tokens: customerTokens,
          order_status: 'pending',
        })
        .select()
        .single();

      if (createError) {
        // If we get a unique constraint violation, it means another request created the order
        // Retry by fetching the existing order
        if (createError.code === '23505') {
          console.log('‚ö†Ô∏è [UPDATE CART] Race condition detected, fetching existing order...');
          
          const { data: existingOrder, error: fetchError } = await supabaseAdmin
            .from('table_orders')
            .select('*')
            .eq('table_id', tableId)
            .in('order_status', ['pending', 'processed'])
            .maybeSingle();

          if (fetchError || !existingOrder) {
            console.error('‚ùå [UPDATE CART] Error fetching order after race condition:', fetchError);
            return NextResponse.json({ error: 'Failed to create order' }, { status: 500 });
          }

          // Update the existing order with new items
          const existingItems = existingOrder.order_items || [];
          const mergedItems: Array<{
            product_id: string;
            quantity: number;
            price: number;
            name: string;
            customer_id?: string;
            customer_token?: string;
            processed?: boolean;
          }> = [...existingItems];
          
          items.forEach((item: { product_id: string; quantity: number; price: number; name: string }) => {
            const existingItemIndex = mergedItems.findIndex(
              (oi) => oi.product_id === item.product_id && oi.customer_token === customerToken
            );

            if (existingItemIndex >= 0) {
              mergedItems[existingItemIndex] = {
                ...mergedItems[existingItemIndex],
                quantity: item.quantity,
              };
            } else {
              mergedItems.push({
                ...item,
                customer_token: customerToken,
                processed: false,
              });
            }
          });

          const mergedItemsFiltered = mergedItems.filter((item) => item.quantity > 0);
          const mergedSubtotal = mergedItemsFiltered.reduce((sum: number, item) => sum + item.price * item.quantity, 0);
          const mergedTotal = mergedSubtotal;
          const mergedCustomerTokens = Array.from(new Set([
            ...(existingOrder.customer_tokens || []),
            customerToken,
          ]));

          const { data: updatedOrder, error: updateError } = await supabaseAdmin
            .from('table_orders')
            .update({
              order_items: mergedItemsFiltered,
              subtotal: mergedSubtotal,
              total: mergedTotal,
              customer_tokens: mergedCustomerTokens,
              updated_at: new Date().toISOString(),
            })
            .eq('id', existingOrder.id)
            .select()
            .single();

          if (updateError) {
            console.error('‚ùå [UPDATE CART] Error updating order after race condition:', updateError);
            return NextResponse.json({ error: 'Failed to create order' }, { status: 500 });
          }

          console.log('‚úÖ [UPDATE CART] Order updated after race condition:', {
            orderId: updatedOrder.id,
            itemCount: updatedOrder.order_items.length,
          });

          // Mark table as occupied if it's currently available (first successful POST)
          if (table.status === 'available') {
            await supabaseAdmin
              .from('tables')
              .update({
                status: 'occupied',
                updated_at: new Date().toISOString(),
              })
              .eq('id', tableId);
            console.log('‚úÖ [UPDATE CART] Table marked as occupied after race condition');
          }

          return NextResponse.json({ 
            order: updatedOrder,
            sessionId: table.session_id // Return session_id so client can store it
          });
        }

        console.error('‚ùå [UPDATE CART] Error creating table order:', createError);
        return NextResponse.json({ error: 'Failed to create order' }, { status: 500 });
      }

      console.log('‚úÖ [UPDATE CART] Order created successfully:', {
        orderId: newOrder.id,
        status: newOrder.order_status,
        itemCount: newOrder.order_items.length,
      });

      // Mark table as occupied if it's currently available (first successful POST)
      if (table.status === 'available') {
        await supabaseAdmin
          .from('tables')
          .update({
            status: 'occupied',
            updated_at: new Date().toISOString(),
          })
          .eq('id', tableId);
        console.log('‚úÖ [UPDATE CART] Table marked as occupied after order creation');
      }

      return NextResponse.json({ 
        order: newOrder,
        sessionId: table.session_id // Return session_id so client can store it
      });
    }
  } catch (error) {
    console.error('Error in table order POST:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

